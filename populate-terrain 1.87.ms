(
	/* This software is free and unlimited for personal and commercial use.
	2011-2012 Marc Lorenz. All rights reserved.
	
	changlog :	
	
	V.1.87 
	updated by Nawras Ryhan to support Max2018 and Max 2019 
	the issue with V.1.86 that it use Normalize_Spl which was replaced with Normalize_Spline2 modifier as a part of the spline tools update 
	so calling the legacy one using " createInstance Normalize_Spl forceCreate:on" solves that as long as 3ds Max still support the legacy Normlize .
		*/
	
--populate
global mlpt_populate_path =getFilenamePath(getSourceFileName())
--------------------------------

--DEBUG----------------------
--override
--mlpt_populate_path =mlpt_populate_path+"\\setup\\Scripts\\Populate-Terrain\\"
--------------------------------

	--cache meshop/polyOp structs...faster and less memory leaking
meshopgetEdgesUsingVert=meshop.getEdgesUsingVert
meshopGetVertsUsingEdge=meshop.getVertsUsingEdge
polyOpGetEdgeFaces=polyOp.getEdgeFaces
polyOpGetEdgesUsingVert=polyOp.getEdgesUsingVert
polyOpGetVert=polyOp.getVert
polyOpSetVert=polyOp.setVert
polyOpGetVertsUsingEdge=polyOp.getVertsUsingEdge
polyOpGetVertsUsedOnlyByFaces=polyOp.getVertsUsedOnlyByFaces
polyOpGetFaceDeg=polyOp.getFaceDeg
polyOpDeleteVerts=polyOp.deleteVerts

resumeediting()
	
local populate_version=1.87
local ini_location="$plugcfg/populate-terrain.ini"

local populate_title="Populate:Terrain "+(populate_version as string)

global mlpt_dialog_populate,mlpt_ro_common,mlpt_ro_postprocessing,mlpt_ro_about,mlpt_ro_options
global mlpt_currentObject
	
try(destroyDialog mlpt_dialog_populate) catch()

local fileMissingMessage="Files missing - please reinstall Populate:Terrain"
local randomAppDataID=3757904 --used for storing ID in modifiers created by script
local randomAppDataSettings=3757905 --used for storing settings in base nodes
local randomAppDataNodeID=3757906 --used for picked nodes, to find them by name/string, if renamed etc.
local mlpt_green=color 110 228 0
local mlpt_returnValue

--Session Settings
global struct_settings 
struct struct_settings (dialog_width,dialog_height,subdivs_x,subdivs_y,size_x,size_y,percent_x,percent_y,square,subdiv_mode,\
	bordermode,meshingmethod,debug_mode,version,adaptive_refinement,adaptive_refinement_vertspercell,adaptive_refinement_maxsubdivs,automethod, \
	relax_on,turbosmooth_on,relax_value,relax_iterations,turbosmooth_iterations,turbosmooth_isolinedisplay,cookie_cut,cookie_cut_nodehandle,cookie_invert)
	
global mlptSettings
if not isProperty mlptSettings "version" or mlptSettings.version!=populate_version do mlptSettings=undefined --reset when settings from old version
if (mlptSettings==undefined) do mlptSettings = struct_settings dialog_width:348 dialog_height:526 \
	subdivs_x:10 subdivs_y:10 size_x:10 size_y:10 percent_x:10 percent_y:10 square:false subdiv_mode:1 \
	bordermode:1 meshingmethod:1 debug_mode:false version:populate_version \
	adaptive_refinement:false adaptive_refinement_vertspercell:4 adaptive_refinement_maxsubdivs:8 automethod:true \
	relax_on:false turbosmooth_on:false relax_value:0.5 relax_iterations:100 turbosmooth_iterations:1 turbosmooth_isolinedisplay:false \
	cookie_cut:true cookie_cut_nodehandle:undefined cookie_invert:false

global mlpt_dialogPos
if mlpt_dialogPos==undefined do mlpt_dialogPos=unsupplied	--otherwise crash when dialog created using "undefined" pos

if mlpt_dialogMode==undefined then mlpt_dialogMode=#compact
local LastSubRollout = 1
local lvBackcolor = ((colorman.getColor #rollupTitleFace )*255) as color
local lvActivecolor = ((colorman.getColor #activeCommand )*255) as color
local lvTextcolor = ((colorman.getColor #windowText )*255) as color
local lvWindowcolor = ((colorman.getColor #window )*255) as color
if lvWindowcolor.r>=225 then lvWindowcolor=white

fn pickFiltSpline o = (isShapeObject o and selection[1]!=o) --dont pick currently selected object
fn pickFiltGeometry o = (superClassOf o == GeometryClass or isShapeObject o)

	--takes object, returns anim handle and appdata stamp
	--returning string can be stored in appdata, ini xml...
fn getHandleFromNode o appDataChannel:randomAppDataNodeID = if isValidNode o do
(
	local randomClassID
		--test if appdata stamp ID is in node.
	local alreadyStamped=getAppdata o appDataChannel
	if alreadyStamped!=undefined then try (local alreadyUsedClassID=execute alreadyStamped); catch(alreadyStamped=undefined)
	if alreadyStamped!=undefined and isKindOf alreadyUsedClassID array then randomClassID=alreadyUsedClassID --stamped ID found, use existing ID
	else 
	(
		randomClassID=genClassID returnValue:true
		setAppData o appDataChannel (randomClassID as string)--store random class ID into picked obj, to find it later when renamed, merged etc.
	)

	local thisHandle=GetHandleByAnim o
	
	#(thisHandle,randomClassID) --return handle data as string

)
	--finds object from handle string generated by getHandleFromNode
fn getNodeFromHandle handleArray appDataChannel:randomAppDataNodeID=
(
	local returnNode=undefined
	if isKindOf handleArray array do 
	(
		local handle=handleArray[1] as IntegerPtr
		local randomClassID=handleArray[2]
		local foundObj=GetAnimByHandle handle --find node by anim handle
		if isValidNode foundObj do --if found, test if appdata stamp ID is in node.
		(
			if (getAppdata foundObj appDataChannel)==randomClassID do returnNode=foundObj --node found, store for return
		)

		for i in objects while returnNode==undefined do --if node not found, search whole scene for appdata stamp ID
		(
			if (getAppdata i appDataChannel)==(randomClassID as string) do returnNode=i
		)
	)
	returnNode
)

-------
-- GW draw methods
-------
/*
	--function by denisT
	--http://forums.cgsociety.org/showthread.php?t=977505
      global easyViewSelectionBBox
      unRegisterRedrawViewsCallback easyViewSelectionBBox
      
      fn easyViewSelectionBBox =
      (
      	nodes = for node in selection where iskindof node GeometryClass collect node
      	if nodes.count > 0 do
      	(
      		view = viewport.activeViewport
      		local bmin = [1e9,1e9,0], bmax = [-1e9,-1e9,0]
      
      		gw.setTransform (matrix3 1)
      		transPoint = gw.hTransPoint
      		for node in nodes do
      		(
      			mesh = snapshotasmesh node
      			for v=1 to mesh.numverts do
      			(
      				vp = transPoint (GetVert mesh v)
      				if vp.x < bmin.x do bmin.x = vp.x
      				if vp.x > bmax.x do bmax.x = vp.x
      				if vp.y < bmin.y do bmin.y = vp.y
      				if vp.y > bmax.y do bmax.y = vp.y
      			)
      			free mesh
      		)
      		w = (bmax.x - bmin.x) as integer
      		h = (bmax.y - bmin.y) as integer
      		rect = box2 bmin.x bmin.y w h
      		gw.hPolyline #(bmin, point3 bmax.x bmin.y 0, bmax, point3 bmin.x bmax.y 0) on rgb:#(orange,orange,orange,orange)
      		gw.hText (bmin + [5,h-20,0]) ("Size: [" + (w as string) + ", " + (h as string) + "]") color:orange
      		gw.enlargeUpdateRect rect
      		gw.updateScreen()
      	)
      )
      registerRedrawViewsCallback easyViewSelectionBBox
      completeRedraw()
	  */

global mlpt_drawBoundingGrid, mlpt_initBoundingGrid, mlpt_subdivsX, mlpt_subdivsY

fn mlpt_drawBoundingGrid o subdivs_x subdivs_y=
(
	local tm = preRotateZ (matrix3 1) 0  
	local bbox = nodeGetBoundingBox o tm
	local a=bbox[1]
	local b=bbox[2]
	local size=(b-a)
	local w=size[1]
	local l=size[2]
	local h=size[3]
	
	gw.setTransform(tm)
		
	local lineArrays = #()
	a_orig=copy a
	for i=0 to subdivs_x do
	(
		append lineArrays #([a.x,a.y,a.z] ,[a.x, a.y, b.z], [a.x, b.y, b.z],[a.x, b.y, a.z])
		a.x+=(w/subdivs_x)
	)
	a=a_orig
	for i=0 to subdivs_y do
	(
		append lineArrays #([a.x,a.y,a.z] ,[a.x, a.y, b.z],[b.x, a.y, b.z],[b.x, a.y, a.z])
		a.y+=(l/subdivs_y)
	)
	gw.setColor #line mlpt_green
	for l in lineArrays do gw.polyline l true 
	gw.enlargeUpdateRect #whole
	gw.updateScreen() 
)
--fn mlpt_initBoundingGrid=for o in selection do mlpt_drawBoundingGrid o mlpt_subdivsX mlpt_subdivsY --affect all selected objects
fn mlpt_initBoundingGrid=if selection.count==1 do for o in selection where (superClassOf o == GeometryClass or isShapeObject o) do mlpt_drawBoundingGrid o mlpt_subdivsX mlpt_subdivsY --only show if 1 object is selected
fn register_boundinggrid=
(
	unregisterRedrawViewsCallback mlpt_initBoundingGrid
	registerRedrawViewsCallback mlpt_initBoundingGrid 
	redrawviews()
)
fn unregister_boundinggrid=
(
	unregisterRedrawViewsCallback mlpt_initBoundingGrid
	--redrawviews()
	forcecompleteredraw() --max 2011 fix
)
-------
-- GW draw methods end
-------

fn updateAllRolloutSettings overwrite:false=
(
	mlpt_ro_common.updateSettings overwrite:overwrite
	mlpt_ro_postprocessing.updateSettings overwrite:overwrite
)
fn storeSettingsIntoModifier currentObject=	if isValidNode currentObject do 
(
	local thisModifier=currentObject.modifiers[1]
	if ((validModifier currentObject thisModifier) and (getAppData thisModifier randomAppDataID)=="1") do	--check if populate:terrain modifier is already present
	(
		setAppData thisModifier randomAppDataSettings (mlptSettings as string) --store current settings into modifier
	)
)

fn getCurrentObject=
(
	local currentlySelected=selection[1]
	
	--trimShape=getNodeFromHandle mlptSettings.cookie_cut_nodehandle
	
	case selection.count of
	(
		0: try(mlpt_dialog_populate.lbl_status.text="Select a geometry or spline object"); catch();
		1: if isValidNode currentlySelected do if (superClassOf currentlySelected == GeometryClass or isShapeObject currentlySelected) do currentlySelected
		default: try(mlpt_dialog_populate.lbl_status.text="Please change selection to a single object"); catch();
	)
)
	--get world aligned bounding box, returns o.x, o.y, o.z
fn getBBox o=if isValidNode o do
(
	local tm = preRotateZ (matrix3 1) 0  
	local bbox = nodeGetBoundingBox o tm
	bbox[2]-bbox[1]
)
	--function by DenisT
	--pre:0.1 ... 6.66->6.7
 fn roundFloat d pre:1 =
 (
  d = (d as float)/pre
  v = if (d - (v1 = floor d)) > ((v2 = ceil d) - d) then v2 else v1 
  v*pre
 )
 
-------
-- selection change callback
-------
global mlpt_objChanged
fn mlpt_objChanged thisEvent thisNodes =
(
	--format "% %\n" thisEvent thisNodes
	--a=getCurrentObject()
	--print a
	mlpt_currentObject=getCurrentObject()
	if mlpt_dialog_populate!=undefined do mlpt_dialog_populate.dialog_refresh()
)
	--remove previous callback
fn mlpt_objChangedRemove no_gc:false=
(
	mlpt_callbackSelectionChanged=undefined
	mlpt_callbackDeleted=undefined
	mlpt_callbackNameChanged=undefined
	mlpt_callbackAdded=undefined
	if not no_gc do gc lite:true
)
mlpt_objChangedRemove()
global mlpt_callbackSelectionChanged=NodeEventCallback selectionChanged:mlpt_objChanged mouseUp:false
global mlpt_callbackDeleted=NodeEventCallback deleted:mlpt_objChanged mouseUp:false
global mlpt_callbackNameChanged=NodeEventCallback nameChanged:mlpt_objChanged mouseUp:false
global mlpt_callbackAdded=NodeEventCallback added:mlpt_objChanged mouseUp:false
-------
-- selection change callback end
-------


local startTime

--------------------------------------------
-- TERRAIN CREATION FUNCTIONS
--------------------------------------------

-- REDRAW METHODS
local oldPanel
	--http://forums.cgsociety.org/showthread.php?f=98&t=1006118
fn stopRedraw=
(
	commandHWND = (windows.getChildHWND #max "Command Panel") --try finding command panel by name
	if commandHWND != undefined and classOf commandHWND==Array then commandHWND=commandHWND[1]
	else 
	(		--if find by name failed (localized max versions) look for command panel in a different way
		first_child_hwnd = for i in (windows.getchildrenhwnd #max) where i[4] == "SysTabControl32" do exit with i[1]
		if classOf(first_child_hwnd)==IntegerPtr then commandHWND = uiaccessor.getparentwindow first_child_hwnd
		if commandHWND==undefined do commandHWND = windows.getmaxhwnd() --if no command panel try finding whole max window
	)
	if commandHWND !=undefined do windows.sendmessage commandHWND 0xB 0 0
)
fn resumeRedraw=
(
	commandHWND = (windows.getChildHWND #max "Command Panel")
	if commandHWND != undefined and classOf commandHWND==Array then commandHWND=commandHWND[1]
	else 
	(
		first_child_hwnd = for i in (windows.getchildrenhwnd #max) where i[4] == "SysTabControl32" do exit with i[1]
		if classOf(first_child_hwnd)==IntegerPtr then commandHWND = uiaccessor.getparentwindow first_child_hwnd
		if commandHWND==undefined do commandHWND = windows.getmaxhwnd() --if no command panel try finding whole max window
	)
	if commandHWND !=undefined do windows.sendmessage commandHWND 0xB 1 0
)
fn stopRedrawPanel=
(
	oldPanel = getCommandPanelTaskMode() --remember the old command panel tab
	stopRedraw()
	setCommandPanelTaskMode mode:#create
)
fn resumeRedrawPanel=
(
	if oldPanel!=undefined do setCommandPanelTaskMode oldPanel --switch back to the previous command panel tab
	if selection==undefined do select selection --command panel redraw fix
	resumeRedraw()
	if getCommandPanelTaskMode()==#modify do --redraw fix
	(
		if $!=undefined and $.modifiers[1]!=undefined do modPanel.setCurrentObject $.modifiers[1]
	)
	--classof $  --refraw fix
	--forcecompleteredraw()
)
-- REDRAW METHODS END

fn createTerrain thisTerrainSpline normalizeLength:10 = if isShapeObject thisTerrainSpline do
(
	mod_normalizeSpline=createInstance Normalize_Spl forceCreate:on length:normalizeLength
	addModifier thisTerrainSpline mod_normalizeSpline
	thisTerrain=Terrain name:"mlpt_tempmesh_terr" --retriangulate:true
	terrainOps.addOperand thisTerrain thisTerrainSpline
	--delete thisTerrainSpline
	thisTerrain
)

fn booleanIntersect a b engine:#boolean=
(
	case engine of
	(
		#boolean:
		(
			boolObj.createBooleanObject a
			boolObj.setBoolOp a 5
			boolObj.setBoolCutType a 4
			boolObj.SetOperandB a b 4 5
			boolObj.setOptimize a true
		)
		#proboolean:	--geht super mit fill mode. manchmal nicht mit terrain?
		(
			ProBoolean.createBooleanObject a b 1 2 1
			ProBoolean.SetCookieCut a true
			ProBoolean.SetPlanarEdgeRemoval a 2 --edge removal 3 ganz schlecht..macht zusätzl. verts an edge!!
		)
		#procutter: --geht nicht mit inseln=fill mode? geht gut mit terrain?
		(
			ProCutter.CreateCutter a 4 true false false false false
			ProCutter.AddStocks a b 1 1
			ProCutter.SetPlanarEdgeRemoval a 3
		)
	)	
)
fn booleanSubstract a b engine:#proboolean _invert:false=
(
	if _invert then method=1 else method=2
	case engine of
	(
		#proboolean:	--geht super mit fill mode. manchmal nicht mit terrain?
		(
			ProBoolean.createBooleanObject a b method 2 1
			ProBoolean.SetCookieCut a true
			ProBoolean.SetPlanarEdgeRemoval a 2 --edge removal 3 ganz schlecht..macht zusätzl. verts an edge!!
		)
	)	
)
	
fn flattenMesh o=
(
	local thisPlane = [0,0,1] --plane normal
	meshop.moveVertsToPlane o #all thisPlane 0.0 
)

--http://forums.cgsociety.org/showthread.php?f=98&t=817888&highlight=normals+view
--returns bitarray of faces that are not pointing upwards in world space
fn collectFlippedMeshFaces obj flipOnlyIfAllFacesPointingDownwards:false fixFlippedFaces:false deleteFlippedFaces:false=	--flip: flip found faces
(
	local obj_faces=obj.faces as bitarray
	local flipped_faces = #{}
	for f in obj_faces where (in coordsys world getFaceNormal obj f).z < 0 do append flipped_faces f
		
		--if all faces are pointing down them flip them
	if flipOnlyIfAllFacesPointingDownwards and (obj_faces.numberset==flipped_faces.numberset) then meshop.flipNormals obj flipped_faces
	else if fixFlippedFaces then meshop.flipNormals obj flipped_faces
	else if deleteFlippedFaces then meshop.deleteFaces obj flipped_faces delIsoVerts:true
	else flipped_faces
)
	--removes vertices, leaves faces intact
fn removePolyVerts obj vertices=
(		
		--check if obj is editable poly
	if classOf obj == editable_poly then
	(
		if selection.count!=1 and selection[1]!=obj do select obj --only select if not already selected...performance!
		setCommandPanelTaskMode mode:#modify
		polyOp.setvertselection obj vertices
		--subobjectlevel = 1 --change to vertex level
		obj.Remove() --remove the current selection
		--subobjectLevel = 0
	)
		--check if object is editable poly modifier that should be updated
	else if classOf obj.modifiers[1] == Edit_Poly then 
	(
		local thisModifier=obj.modifiers[1]
		if selection.count!=1 and selection[1]!=obj then select obj --only select if not already selected...performance!
		setCommandPanelTaskMode mode:#modify
		thisModifier.SetSelection #Vertex vertices
		--subobjectlevel = 1 --change to vertex level
		thisModifier.buttonOp #removeVertex --remove the current selection
		
			--loop removeVertex operation until there is no change anymore
		local previousVertexCount=0
		while (local thisCount=(thisModifier.GetSelection #Vertex).numberset) > 0 and previousVertexCount!=thisCount do
		(
			previousVertexCount=thisCount
			thisModifier.buttonOp #removeVertex --remove leftover vertices? see terrain_quad.max
		)
		
		if (thisModifier.GetSelection #Vertex).numberset > 0 do thisModifier.buttonOp #DeleteVertex --good idea? delete if looped remove still lefts vertices

		--thisModifier.SetSelection #Vertex #{}
		--subobjectLevel = 0

	)
	else false
)
--find vertices on open edges that are not connected to other faces
fn collectOpenEdgeVertices obj deleteVerts:false keepQuads:true=	--deleteVerts: delete found vertices
(
	local vertices = #{}
	local borderEdges = polyOp.getOpenEdges obj
	local facesToSearch = #{}
	for i in borderEdges do
	(
		join facesToSearch (polyOpGetEdgeFaces obj i as bitarray) --collect faces that though open edges
	)
	for f in facesToSearch do
	(
		local thisFaceOpenEdgeVerts=polyOpGetVertsUsedOnlyByFaces obj f	--slow?
		local isNotQuad=if keepQuads then (polyOpGetFaceDeg obj f)>4 else true
		if isNotQuad do join vertices thisFaceOpenEdgeVerts
	)
	
	vertsOnStraightLine=#{}
	for v in vertices do
	(
		--get the edges using the vertex to check the count
		nVerts = (polyOpGetEdgesUsingVert obj v) as array
		if nVerts.count == 2 do --if only two edges found, then
		(
			--get the verts of the first egde
			local edge1verts = (polyOpGetVertsUsingEdge obj nVerts[1]) as array
			--calculate the vector defined by the two vertices in the first edge
			local vector1 = (polyOpGetVert obj edge1verts[1]) - (polyOpGetVert obj edge1verts[2])
			--get the verts of the second edge
			local edge2verts = (polyOpGetVertsUsingEdge obj nVerts[2]) as array
			--calculate the vector defined by the two vertices in the second edge
			local vector2 = (polyOpGetVert obj edge2verts[1]) - (polyOpGetVert obj edge2verts[2])
			--calculate the angle between the two normalized vectors
			local a = acos (dot (normalize vector1) (normalize vector2))
			--if the angle is less than the threashold (change 0.01 to whatever threashold you want!)
				
			if a < 60.0 or a > 120.0 do	--60 instead of 0.01. not looking for straight but corners
			(
				append vertsOnStraightLine v
			)
		)
	)
	
	vertices=vertices*vertsOnStraightLine --intersect both verts collections
	
	if deleteVerts then removePolyVerts obj vertices
	else vertices	--return array with found vertices
)


--creat an edit poly mod on originalObj, delete original geometry and attach resultPlane to it
--updateModifier update existing edit poly modifier at first stack position
fn createAndAttachToEditPolyMod originalObj resultPlane updateModifier:undefined tagWithAppData:false =
(
	if updateModifier!=undefined and validModifier originalObj updateModifier then
	(
		local mod_editPoly=updateModifier
		mod_editPoly.enabled=true
	)
	else
	(
		local mod_editPoly=edit_poly()
		mod_editPoly.name="Populate:Terrain"
		addModifier originalObj mod_editPoly
	)
	if tagWithAppData do setAppData mod_editPoly randomAppDataID "1" --tag modifier
	if selection.count!=1 and selection[1]!=originalObj do select originalObj --only select if not already selected...performance!

	--modPanel.setCurrentObject mod_editPoly --activate the modifier 

	local this_faces=originalObj.faces as bitarray

	setCommandPanelTaskMode mode:#modify --make modifier panel "visible" to maxscript
	--subObjectLevel = 4
	mod_editPoly.SetSelection #Face this_faces
	mod_editPoly.ButtonOp #DeleteFace
	mod_editPoly.attach resultPlane --editPolyNode:originalObj
	mod_editPoly.SetSelection #Face #{}
	--subObjectLevel = 0
)
	--loop through all sub object splines, close if open
fn closeSubObjectSplines spl checkOnly:false=
(
	local returnValue=true
	if (classOf spl == Splineshape and classOf spl ==line) then
	(
		if checkOnly then
		(
			for i=1 to (numSplines spl) do if not isClosed spl i do returnValue=false
		)
		else 
		(
			for i=1 to (numSplines spl) do if not isClosed spl i do 
			(
				close spl i
				updateShape spl
			)
		)
	)
	else returnValue=true
	returnValue
)
	--convert spline 
fn prepareSplineForTerrain originalObj shapeMode:#auto normalizeLength:30=
(
	--print originalObj.height
	local obj
	case shapeMode of
	(
		#terrainCompound:
		(
			tempObj=copy originalObj
			obj=createTerrain tempObj normalizeLength:normalizeLength
			delete tempObj
		)
		#fill:
		(
			local isShapeClosed=closeSubObjectSplines originalObj checkOnly:true
			if isShapeClosed then obj=snapshot originalObj name:"mlpt_tempmesh"
			else
			(
				tempObj=copy originalObj
				closeSubObjectSplines tempObj
				obj=snapshot tempObj
				delete tempObj
			)
			
		)
	)
	obj --returnerew
)
	--create solid extruded object for boolean operations
fn createBooleanSolid obj height mode:#splinefrompolyextrude cap:true=
(
	if height<0.1 do height=1.0	--protect from zero height shell
	case mode of
	(
		#shell:
		(
			local mod_shell = shell Bevel:false Segments:1 innerAmount:0 outerAmount:height overrideInnerMatID:false overrideOuterMatID:false overrideMatID:false autosmooth:false autoSmoothAngle:45 overrideSmoothingGroup:false edgeMapping:1 selectEdgeFaces:false selectInnerFaces:false selectOuterFaces:false straightenCorners:false
			addModifier obj mod_shell
		)
		#splinefrompolyextrude:
		(
			if isValidNode $mlpt_tempplane_createBooleanSolidShape do delete $mlpt_tempplane_createBooleanSolidShape
			convertToPoly obj
			local borderEdges = polyOp.getOpenEdges obj
			polyOp.createShape obj borderEdges name:"mlpt_tempplane_createBooleanSolidShape" smooth:false
			local borderSpline=$mlpt_tempplane_createBooleanSolidShape
			
			--check if all sub object splines are closed for extrude
			closeSubObjectSplines borderSpline
			
			local mod_extrude = extrude amount:height segs:1 capStart:cap capEnd:cap capType:0 output:1 matIDs:off smooth:off mapCoords:false realWorldMapSize:false
			addModifier borderSpline mod_extrude
			delete obj
			obj=borderSpline
		)
		#splineextrude:
		(
				--check if all sub object splines are closed for extrude
			closeSubObjectSplines borderSpline
			local mod_extrude = extrude amount:height segs:1 capStart:cap capEnd:cap capType:0 output:1 matIDs:off smooth:off mapCoords:false realWorldMapSize:false
			addModifier obj mod_extrude
		)
	)
	convertToMesh obj
	CenterPivot obj
	obj.position.z-=height/2	--move to mid height, better for boolean
	obj --return obj
)

	--wraps obj over target_obj along the world z axis
	--expects MESH returns POLY
function zWrapMesh obj target_obj fixLeftoverVerts:true keepShootingIfRayFailed:true deleteMissedVerts:false doubleSidedHitTest:false bbox: snapToVertsPositions: = 
(

	local zeroHeight=bbox[1].z
	local verts = obj.verts as bitarray --#{1..(getNumVerts obj)}
	local leftover_verts = #{}
	if deleteMissedVerts do local vertsToDelete=#{}
	
	rm = RayMeshGridIntersect() --create an instance of the Reference Target 
		--http://forums.cgsociety.org/showthread.php?f=98&t=321531&highlight=RayMeshGridIntersect
	rm.Initialize 10 --init. the voxel grid size to 10x10x10 --http://forums.cgsociety.org/showthread.php?f=98&t=321531&highlight=RayMeshGridIntersect
	rm.addNode target_obj
	rm.buildGrid()
	
	numberOfRayIterations=0
	
	for i in verts do
	( 
		vertPos = getVert obj i
		vertPos0=[vertPos.x,vertPos.y,zeroHeight]
		rayTarget = normalize (vertPos0 - vertPos)
		
		theHitsCount=rm.intersectRay vertPos rayTarget doubleSidedHitTest
			
		if theHitsCount>0 then --if first ray hit surface
		(
			closestHit=rm.getClosestHit()
			dist=rm.getHitDist closestHit
			newVertPos=vertPos+(rayTarget*dist)
			setVert obj i newVertPos
		)
		else if keepShootingIfRayFailed then --keep trying
		(	--crazy ray vector bend to find neighboring area
			local searchRadius=1e-006
			local maxSearchRadius=0.1
			local stepSize=10
			local	searchRays=#()
			local keepSearching=true
			do
			(
				rayArrayEnd=	 #([vertPos.x+searchRadius,vertPos.y+searchRadius,zeroHeight],
										[vertPos.x-searchRadius,vertPos.y+searchRadius,zeroHeight],
										[vertPos.x+searchRadius,vertPos.y-searchRadius,zeroHeight],
										[vertPos.x-searchRadius,vertPos.y-searchRadius,zeroHeight],
										[vertPos.x,vertPos.y+searchRadius,zeroHeight],
										[vertPos.x,vertPos.y-searchRadius,zeroHeight],
										[vertPos.x+searchRadius,vertPos.y,zeroHeight],
										[vertPos.x-searchRadius,vertPos.y,zeroHeight])
				rayArrayStart=#([vertPos.x+searchRadius,vertPos.y+searchRadius,vertPos.z],
										[vertPos.x-searchRadius,vertPos.y+searchRadius,vertPos.z],
										[vertPos.x+searchRadius,vertPos.y-searchRadius,vertPos.z],
										[vertPos.x-searchRadius,vertPos.y-searchRadius,vertPos.z],
										[vertPos.x,vertPos.y+searchRadius,vertPos.z],
										[vertPos.x,vertPos.y-searchRadius,vertPos.z],
										[vertPos.x+searchRadius,vertPos.y,vertPos.z],
										[vertPos.x-searchRadius,vertPos.y,vertPos.z])
				for r=1 to rayArrayEnd.count do
				(
						--try with ray cluster
					rayTarget = normalize (rayArrayEnd[r] - rayArrayStart[r])
					theHitsCount=rm.intersectRay rayArrayStart[r] rayTarget doubleSidedHitTest
					if theHitsCount>0 do 
					(
						dist=rm.getHitDist (rm.getClosestHit())
						hitPos=rayArrayStart[r]+(rayTarget*dist)
						append searchRays hitPos
					)
					
					if searchRays.count==0 do
					(
							--if ray cluster failed try ray cluster with slow method (sometimes holes problem.max)
						shootRay = ray rayArrayStart[r] rayTarget
						hit=intersectRay target_obj shootRay
						if hit!=undefined do 
						(
							append searchRays hit.pos
						)
					)
					
				)
				numberOfRayIterations+=1
				
				if searchRadius>=maxSearchRadius then keepSearching=false
				else searchRadius*=stepSize
			)
			while searchRays.count==0 and keepSearching
			--print searchRadius
			if searchRays.count>0 then
			(
				local averageZ=0.0
				for r in searchRays do
				(
					averageZ+=r.z
					--if i==1580 do point pos:r drawontop:on constantscreensize:on centermarker:on wirecolor:green
				)
				averageZ=averageZ/searchRays.count
				setVert obj i [vertPos0.x,vertPos0.y,averageZ]
			)
			else
			(
				--setVert obj i vertPos0
				append leftover_verts i
			)
		)
		else 
		(
			if deleteMissedVerts then append vertsToDelete i
			else setVert obj i [vertPos0.x,vertPos0.y,zeroHeight]	--set vert to zero bounding box height
		)
	)
	
	--rm.PrintStats() 
	if mlptSettings.debug_mode do format "Ray Search Iterations: % Fixed Vertices: %\n" numberOfRayIterations leftover_verts.numberset
	rm.free()

		--fix leftover vertices by analysing neighbor vertices on the edge, using their average height
	if fixLeftoverVerts and leftover_verts.numberset>0 do
	(
		for i in leftover_verts do
		(
			local edgesToProcess=meshopGetEdgesUsingVert obj i
			if borderEdges!=undefined do edgesToProcess=borderEdges*edgesToProcess
			local neighboringVerts=meshopGetVertsUsingEdge obj edgesToProcess
			neighboringVerts-=leftover_verts --dont use leftover vertices for average values
			
			local averageVertexHeight=0.0
			for i in neighboringVerts do
			(
				local thisVert=getVert obj i
				averageVertexHeight+=thisVert.z
			)
			averageVertexHeight=averageVertexHeight/neighboringVerts.numberset
			badVertex=getVert obj i
			local badVertexNewPos=[badVertex.x,badVertex.y,averageVertexHeight]
			setVert obj i badVertexNewPos
		)
	)
	
	convertToPoly obj
	if deleteMissedVerts do 
	(
		polyOpDeleteVerts obj vertsToDelete
	)
)
/*
	--legacy, not used anymore
function zWrapUsingSkinWrapMorpher resultPlane obj snapshotFlat centerpos=
(
	local mod_morpher=morpher Autoload_of_targets:1
	addModifier obj mod_morpher
	WM3_MC_BuildFromNode mod_morpher 1 snapshotFlat
	WM3_MC_SetValue mod_morpher 1 100.0

	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Morph:          %\n" redrawTime
	
	if thisProgressBar!=undefined do thisProgressBar.value=50

	resultPlane.position=centerpos

	local skin_wrap_mod=Skin_Wrap weightAllVerts:true engine:0 falloff:0.001 meshlist:#(obj)
	addModifier resultPlane skin_wrap_mod
	classOf resultPlane
	WM3_MC_SetValue mod_morpher 1 0.0
	if thisProgressBar!=undefined do thisProgressBar.value=75

)
*/
	--test if object is spline or mesh
fn getObjectType obj=
(
	if (isShapeObject obj) then #spline
	else #mesh
)
	--returns class ob object at given position in the modifier stack
	--slow!
fn getObjectTypeInModifierStack obj stackposition:#baseobject= 
(
	local returnObjectType
	if stackposition==#baseobject then
	(
		case (superclassof obj.baseobject) of
		(
			GeometryClass:returnObjectType=#mesh
			shape:returnObjectType=#spline
		)
	)
	else
	(
		local oldPanel = getCommandPanelTaskMode() --remember the old command panel tab
		stopRedraw()
		setCommandPanelTaskMode mode:#modify
		local oldStackPosition=modPanel.getCurrentObject()
		if stackposition==#baseobject then modPanel.setCurrentObject obj.baseobject 
		else modPanel.setCurrentObject obj.modifiers[stackposition]
		showEndResult =off
		returnObjectType=getObjectType obj
		showEndResult =on

		modPanel.setCurrentObject oldStackPosition
		
		setCommandPanelTaskMode oldPanel --switch back to the previous command panel tab
		resumeRedraw()
	)
	--print returnObjectType
	returnObjectType
)
fn autoDetectSplineMeshingMode obj=
(
	local thisObjDimensions=getBBox obj
	if ((classOf  obj == Splineshape or classOf  obj ==line) and (thisObjDimensions.z>0.0001)) then	2 --CONTOUR LINES
	else 1 --FILL MODE
)
fn getBaseObjectType obj randomAppDataID:randomAppDataID=
(
	local thisModStack=obj.modifiers
	local returnObjectType
	if thisModStack.count>0 then
	(
		local thisStackPosition=1
		
		keepLooking=true
		while thisStackPosition<=thisModStack.count and keepLooking do
		(
			local thisMod=thisModStack[thisStackPosition]
			local thisModClass=classOf thisMod
			if thisModClass==Relax or thisModClass==TurboSmooth or thisModClass==Edit_Poly then
			(
				if (getAppData thisMod randomAppDataID)==undefined then keepLooking=false
				else thisStackPosition+=1
			)
			else keepLooking=false
		)
		if thisStackPosition==1 then returnObjectType=getObjectType obj
		else if thisStackPosition>thisModStack.count then returnObjectType=getObjectTypeInModifierStack obj stackposition:#baseobject
		else returnObjectType=getObjectTypeInModifierStack obj stackposition:thisStackPosition
	)
	else returnObjectType=getObjectType obj
	returnObjectType
)

local mod_vertex_weld=vertex_weld threshold:0.001
fn addVertexWeldMod obj collapseToPoly:false=
(
	addModifier obj mod_vertex_weld
	if collapseToPoly do convertToPoly obj
)
fn linkRelaxMod obj spinner_relax spinner_iterations=
(
	local thisMod
	for i in obj.modifiers where classOf i==Relax and getAppData i randomAppDataID=="1" do
	(
		thisMod=i
	)
	if thisMod!=undefined do
	(
		spinner_relax.controller=thisMod.relax_value.controller
		spinner_iterations.controller=thisMod.iterations.controller
	)
)
fn linkTurboSmoothMod obj spinner_iterations=
(
	local thisMod
	for i in obj.modifiers where classOf i==TurboSmooth and getAppData i randomAppDataID=="1" do
	(
		thisMod=i
	)
	if thisMod!=undefined do
	(
		spinner_iterations.controller=thisMod.iterations.controller
	)
)
fn addRelaxMod obj val iterations tagWithAppData:false=
(
	local mod_relax=relax relax_value:val iterations:iterations Keep_Boundary_Pts_Fixed:1 name:"Populate:Relax"
	addModifier obj mod_relax
	if tagWithAppData do setAppData mod_relax randomAppDataID "1" --tag modifier
	mod_relax.relax_value.controller = bezier_float() --assign controller for link to populate terrain UI
	mod_relax.iterations.controller = bezier_float()
)
fn addTurboSmoothMod obj iterations isolinedisplay tagWithAppData:false=
(
	local mod_turboSmooth=turboSmooth iterations:iterations isolineDisplay:isolinedisplay name:"Populate:TurboSmooth"
	addModifier obj mod_turboSmooth
	if tagWithAppData do setAppData mod_turboSmooth randomAppDataID "1" --tag modifier
	mod_turboSmooth.iterations.controller = bezier_float()  --assign controller for link to populate terrain UI
)
fn deleteRelaxTurboSmoothMods obj randomAppDataID:randomAppDataID=
(
	local modifiersToDelete=#()
	local thisModStack=obj.modifiers
	for m in thisModStack do
	(
		local thisModClass=classOf m
		if thisModClass==Relax or thisModClass==TurboSmooth do
		(
			if (getAppData m randomAppDataID)!=undefined do append modifiersToDelete m
		)
	)
	for m in modifiersToDelete do deleteModifier obj m
)

fn startTerrainCreation originalObj subdivs_x:10 subdivs_y:10 optimizeBorderEdges:true trimToGrid:false shapeMode:#terrainCompound normalizeLength:30 thisProgressBar:false updateModifier:undefined tagWithAppData:false trimShape:undefined trimInvert:false=
	(

	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Start:          %\n" redrawTime

	local obj
	if updateModifier!=undefined then updateModifier.enabled=false
	
		--create boolean solid
		--if result is not a nice closed mesh then try a second time, without flipping normals
	local booleanShapeOK=false
	local trimShapeMesh=undefined
	local count=0
	while booleanShapeOK==false and count<=2 do
		(
		count+=1
			
		if count==2 do
		(
			delete obj
			delete snapshotFlat
			delete snapshotFlatBoolean
		)			
		
		if isShapeObject originalObj then local mode=#shape else mode=#mesh
		
		if mode==#shape then
		(
			obj=prepareSplineForTerrain originalObj shapeMode:shapeMode normalizeLength:normalizeLength
		)
		else --mesh
		(
			obj=snapshot originalObj name:"mlpt_tempmesh1"
		)

		resetXForm obj --1. step
		CenterPivot obj --2. step
		--convertToMesh obj
		resetXForm obj --3. step
		convertToMesh obj
		
		local centerpos=obj.pos
		local bbox=nodeLocalBoundingBox obj
		local size=(bbox[2]-bbox[1])
		local w=size[1]
		local l=size[2]
		local h=size[3]
		local zmin=obj.min.z
		local zmax=obj.max.z
		
		if mode==#mesh and count==1 do collectFlippedMeshFaces obj flipOnlyIfAllFacesPointingDownwards:true deleteFlippedFaces:true --delete faces pointing down. if all faces pointing down then flip, dont delete
		
			--create boolean solid of border 
		snapshotFlat=snapshot obj name:"mlpt_tempmesh2"
		if h>0.001 do flattenMesh snapshotFlat
		snapshotFlatBoolean=snapshot snapshotFlat name:"mlpt_tempmesh3"
		
		snapshotFlatBoolean=createBooleanSolid snapshotFlatBoolean h --create solid mesh for boolean intersect

		thisOpenEdges=meshOp.getOpenEdges snapshotFlatBoolean	--get open edges to see if spline extrusion was successful. 0=perfect result, solid extrusion, all capped.
		booleanShapeOK=thisOpenEdges.numberset==0 --check if mesh closed = no open edges
		
		if booleanShapeOK and trimShape!=undefined do
		(
			trimShape=copy trimShape name:"mlpt_temptrimshape"
			trimShape.pos.z=obj.pos.z
			trimShapeMesh=createBooleanSolid trimShape h mode:#splineextrude
		)	
		
		if mlptSettings.debug_mode do
		(
			if count==1 and booleanShapeOK do format "Trimmed using Method 1\n"
			if count==2 and booleanShapeOK do format "Trimmed using Method 2\n"
			if count==2 and not booleanShapeOK do format "Trimmed using Method 2, open edges found\n"
		)
	)
	

	
		--create plane to intersect with boolean solid
	resultPlane=plane pos:centerpos width:w length:l lengthsegs:subdivs_y widthsegs:subdivs_x name:"mlpt_tempplane"
	
	--copy resultPlane name:"TEST"
	--copy snapshotFlatBoolean name:"TEST"
	
	if not trimToGrid then
	(
		booleanIntersect resultPlane snapshotFlatBoolean engine:#proboolean
		if trimShapeMesh!=undefined do booleanSubstract resultPlane trimShapeMesh _invert:trimInvert
		convertToMesh resultPlane
			
		if resultPlane.numfaces<1 then --check if boolean failed, try using other boolean engine
		(
			--nicht elegant!, nochmal alles wenn proboolean failed
			if mlptSettings.debug_mode do format "Boolean method 2\n"

			delete resultPlane
			snapshotFlatBoolean=snapshot snapshotFlat name:"mlpt_tempmesh4"
			snapshotFlatBoolean=createBooleanSolid snapshotFlatBoolean h --create solid mesh for boolean intersect
			resultPlane=plane pos:centerpos width:w length:l lengthsegs:subdivs_y widthsegs:subdivs_x name:"mlpt_tempplane"
			booleanIntersect resultPlane snapshotFlatBoolean engine:#boolean
			convertToMesh resultPlane
		)
		else if mlptSettings.debug_mode do format "Boolean method 1\n"

		if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
		if mlptSettings.debug_mode do format "Boolean:        %\n" redrawTime

		meshop.deleteIsoVerts resultPlane
	)
	else convertToMesh resultPlane
	pushPrompt "Trimming complete"
	
		--if bas object is flat no need to wrap
	if h>0.001 or trimToGrid then
	(
		if thisProgressBar!=undefined do thisProgressBar.value=30

		if mlptSettings.debug_mode do format "Wrap h=%\n" h

			--returns poly
		resultPlane.pos.z=bbox[2].z
		zWrapMesh resultPlane obj bbox:bbox fixLeftoverVerts:(not trimToGrid) keepShootingIfRayFailed:(not trimToGrid) deleteMissedVerts:trimToGrid --snapToVertsPositions:originalObjBorderEdgeVertsPositions
		
		if thisProgressBar!=undefined do thisProgressBar.value=60

		--zWrapUsingSkinWrapMorpher resultPlane obj snapshotFlat centerpos
	)
	
	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Wrap:           %\n" redrawTime

	addVertexWeldMod resultPlane collapseToPoly:true
	
	CenterPivot resultPlane
	
		--store vertices to remove later in edit poly modifier, since operation requires mod panel access anyway
	if optimizeBorderEdges do local verticesToRemove=collectOpenEdgeVertices resultPlane deleteVerts:false

	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Verts collect:  %\n" redrawTime

	if thisProgressBar!=undefined do thisProgressBar.value=90

		--check if resulting poly has faces/boolean was successful
	local returnValue=#ok
	if resultPlane.numfaces>1 then createAndAttachToEditPolyMod originalObj resultPlane updateModifier:updateModifier tagWithAppData:tagWithAppData
	else 
		(
			delete resultPlane
			select originalObj
			returnValue=#emptyResult
		)
		
	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Create Mod:     %\n" redrawTime
		
 	if not trimToGrid then
	(
			--optimize border edges, remove collected vertices
		if optimizeBorderEdges and verticesToRemove!=undefined and verticesToRemove.count>0 do removePolyVerts originalObj verticesToRemove
		if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
		if mlptSettings.debug_mode do format "Optimize:       %\n" redrawTime
	)
	
	--delete obj
	--delete snapshotFlat
	delete $mlpt_temp*
	nodeInvalRect originalObj	--flag object to redraw
	popPrompt()
	returnValue
)
------------------------------------------------------
-- POINT CLOUD GENERATION FUNCTIONS
------------------------------------------------------
	--create offset coordinates for bucket rendering style lookup of cells in a loop
growVoxelCellArray=#([0,0],[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],\ --1 -- 8
	[-2,0],[-2,1],[-2,2],[-1,2],[0,2],[1,2],[2,2],[2,1],[2,0],[2,-1],[2,-2],[1,-2],[0,-2],[-1,-2],[-2,-2],[-2,-1] ,\ --16
	[-3,0],[-3,1],[-3,2],[-3,3],[-2,3],[-1,3],[0,3],[1,3],[2,3],[3,3],[3,2],[3,1],[3,0],[3,-1],[3,-2],[3,-3],[2,-3],[1,-3],[0,-3],[-1,-3],[-2,-3],[-3,-3],[-3,-2],[-3,-1],\ --24
	[-4,0],[-4,1],[-4,2],[-4,3],[-4,4],[-3,4],[-2,4],[-1,4],[0,4],[1,4],[2,4],[3,4],[4,4],[4,3],[4,2],[4,1],[4,0],[4,-1],[4,-2],[4,-3],[4,-4],[3,-4],[2,-4],[1,-4],[0,-4],[-1,-4],[-2,-4],[-3,-4],[-4,-4],[-4,-3],[-4,-2],[-4,-1],\ --32
	[-5,0],[-5,1],[-5,2],[-5,3],[-5,4],[-5,5],[-4,5],[-3,5],[-2,5],[-1,5],[0,5],[1,5],[2,5],[3,5],[4,5],[5,5],[5,4],[5,3],[5,2],[5,1],[5,0],[5,-1],[5,-2],[5,-3],[5,-4],[5,-5],[4,-5],[3,-5],[2,-5],[1,-5],[0,-5],[-1,-5],[-2,-5],[-3,-5],[-4,-5],[-5,-5],[-5,-4],[-5,-3],[-5,-2],[-5,-1], \ --40
	[-6,0],[-6,1],[-6,2],[-6,3],[-6,4],[-6,5],[-6,6],[-5,6],[-4,6],[-3,6],[-2,6],[-1,6],[0,6],[1,6],[2,6],[3,6],[4,6],[5,6],[6,6],[6,5],[6,4],[6,3],[6,2],[6,1],[6,0],[6,-1],[6,-2],[6,-3],[6,-4],[6,-5],[6,-6],[5,-6],[4,-6],[3,-6],[2,-6],[1,-6],[0,-6],[-1,-6],[-2,-6],[-3,-6],[-4,-6],[-5,-6],[-6,-6],[-6,-5],[-6,-4],[-6,-3],[-6,-2],[-6,-1], \ --48
	[-7,0],[-7,1],[-7,2],[-7,3],[-7,4],[-7,5],[-7,6],[-7,7],[-6,7],[-5,7],[-4,7],[-3,7],[-2,7],[-1,7],[0,7],[1,7],[2,7],[3,7],[4,7],[5,7],[6,7],[7,7],[7,6],[7,5],[7,4],[7,3],[7,2],[7,1],[7,0],[7,-1],[7,-2],[7,-3],[7,-4],[7,-5],[7,-6],[7,-7],[6,-7],[5,-7],[4,-7],[3,-7],[2,-7],[1,-7],[0,-7],[-1,-7],[-2,-7],[-3,-7],[-4,-7],[-5,-7],[-6,-7],[-7,-7],[-7,-6],[-7,-5],[-7,-4],[-7,-3],[-7,-2],[-7,-1], \ --56
	[-8,0],[-8,1],[-8,2],[-8,3],[-8,4],[-8,5],[-8,6],[-8,7],[-8,8],[-7,8],[-6,8],[-5,8],[-4,8],[-3,8],[-2,8],[-1,8],[0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,8],[7,8],[8,8],[8,7],[8,6],[8,5],[8,4],[8,3],[8,2],[8,1],[8,0],[8,-1],[8,-2],[8,-3],[8,-4],[8,-5],[8,-6],[8,-7],[8,-8],[7,-8],[6,-8],[5,-8],[4,-8],[3,-8],[2,-8],[1,-8],[0,-8],[-1,-8],[-2,-8],[-3,-8],[-4,-8],[-5,-8],[-6,-8],[-7,-8],[-8,-8],[-8,-7],[-8,-6],[-8,-5],[-8,-4],[-8,-3],[-8,-2],[-8,-1] \ --64
)
growVoxelIterationsCellCount=#([1,1],[2,9],[10,25],[26,49],[50,81],[82,121],[122,169],[170,225],[226,289])
	--returns point positions array of given mesh
fn generatePointsFromMeshVerts obj=
(
	local verts = obj.verts as bitarray
	for i in verts collect GetVert obj i
)
	--returns point positions array of given spline
fn generatePointsFromSpline pointCloud=
(
	--collect all points in point cloud as array with positions
	pointsPositions=#()
	for s = 1 to (numSplines pointCloud) do
	(
		for k = 1 to (numKnots pointCloud s) do
		(
			append pointsPositions (getKnotPoint pointCloud s k)
		)
	)
	pointsPositions
)
	--VOXEL GRID INIT
	--returns addresses of given point clound and voxel grid size
fn initVoxelData points cellSize: pointsPositions: origin: =
(
	data=#()
	for i in points do
	(
		thisPoint=pointsPositions[i]
		pos=[thisPoint.x-origin.x,thisPoint.y-origin.y]/cellSize+0.9999
		if pos.x<1 do pos.x=1
		if pos.y<1 do pos.y=1
		if data[pos.y] == undefined then
		(
			data[pos.y] = #()
			data[pos.y][pos.x] = #{i}
		)
		else if data[pos.y][pos.x] == undefined then data[pos.y][pos.x] = #{i}
		else append data[pos.y][pos.x] i
	)
	data
)
	--returns points in voxel cell for given search pos
fn findVoxelpointsPositions searchPos voxelAdresses min_grow_iterations:6 =
(
	local allVoxelHits=#{}
	local keepsearching_cycle=1
	local finishround=false
	local thisVoxelHits=#{}
	local cycle=1
	do
	(
		for i=growVoxelIterationsCellCount[cycle][1] to (growVoxelIterationsCellCount[cycle][2]) do
		(
			local neighborSearch=searchPos+growVoxelCellArray[i]
			if neighborSearch.y<1 do neighborSearch.y=1	--avoid negative index...dont look outside bounds in array
			if neighborSearch.x<1 do neighborSearch.x=1
			
			thisVoxelHitsRow=voxelAdresses[neighborSearch.y]
			if thisVoxelHitsRow!=undefined do 
			(
				thisVoxelHits=thisVoxelHitsRow[neighborSearch.x]
				if thisVoxelHits==undefined do thisVoxelHits=#{}
			)
			if not thisVoxelHits.isEmpty then --when points have been found
			(
				join allVoxelHits thisVoxelHits --add points to array
				keepsearching_cycle+=1 
				if keepsearching_cycle>=min_grow_iterations do finishround=true --search one more round to avoid block snapping errors
			)
		)
		cycle+=1
		if cycle>growVoxelIterationsCellCount.count do finishround=true
	)
	while not finishround 
	allVoxelHits
)

------------------------------------------------------
-- POINT CLOUD GENERATION FUNCTIONS end
------------------------------------------------------

fn startPointCloudTerrainCreation originalObj subdivs_x:10 subdivs_y:10 normalizeLength: thisProgressBar:false tagWithAppData:false trimShape:undefined=
(
	if mlptSettings.debug_mode do local redrawTime=(timeStamp() - startTime) / 1000.0
	if mlptSettings.debug_mode do format "Start:          %\n" redrawTime

		--check if obj is spline
	if isShapeObject originalObj then
	(
		obj=copy originalObj name:"mlpt_tempspl1"
		local mod_normalizeSpline=Normalize_Spl length:normalizeLength
		addModifier obj mod_normalizeSpline
		convertToSplineShape obj
		local pointsPositions=generatePointsFromSpline obj
	)
		--obj is mesh
	else 
	(
		obj=snapshot originalObj name:"mlpt_tempmesh1"
		local pointsPositions=generatePointsFromMeshVerts obj
	)
	
	local points=#{1..pointsPositions.count}
	
	resetXForm obj --1. step
	CenterPivot obj --2. step
	--convertToMesh obj
	resetXForm obj --3. step
	--convertToMesh obj --slow! why?
	
	local centerpos=obj.pos
	local bbox=nodeLocalBoundingBox obj
	local size=(bbox[2]-bbox[1])
	local w=size[1]
	local l=size[2]
	local h=size[3]
	local zmin=obj.min.z
	local zmax=obj.max.z

		--create plane to intersect with boolean solid
	local resultPlane=plane pos:centerpos width:w length:l lengthsegs:subdivs_y widthsegs:subdivs_x name:"mlpt_tempmesh_plane"
	convertToPoly resultPlane
	--SAUBERER von BBOX
	
	local verts = resultplane.verts as bitarray
	local vertsPos = for i in verts collect polyOpGetVert resultplane i
	--copy resultPlane name:"TEST"
	--copy snapshotFlatBoolean name:"TEST"

		--prepare voxel grid
	--local cellSize=[(w/subdivs_x),(l/subdivs_y)]*10 --voxel cell size=grid cell size=finest res
	local cellSize=[w,l]/64
	local origin=[resultplane.min.x,resultplane.min.y]
	local voxelAdresses=initVoxelData points cellSize:cellSize pointsPositions:pointsPositions origin:origin

	--thisProgressBar=undefined
		--init progress bar
	if thisProgressBar!=undefined do
		(
		local loopcount=verts.numberset
		local percentage=loopcount/100
		local current_progress=0
		)
	
		--start looping verts
	local newVertsPos=#()
	local notfound=0
	for v in verts do 
	(
			--update progress bar
		if thisProgressBar!=undefined do
		(
			current_progress+=1
			if (mod current_progress percentage == 0) do
			(
				thisProgressBar.value=ceil current_progress/percentage
			)
		)

		
		local thisVertPos = vertsPos[v]
		local vert2dPos=[thisVertPos.x,thisVertPos.y]
		
		local searchPos=[thisVertPos.x-origin.x,thisVertPos.y-origin.y]/cellSize+0.9999

		local pointsToMeasure=findVoxelpointsPositions searchPos voxelAdresses --min_grow_iterations:3
		
			--this shouldn't happen...no points found, even after bucket rendering style cell grow...use all points for measure
		if pointsToMeasure.isEmpty do 
		(
			notfound+=1
			pointsToMeasure=points
		)
		
		local smallestDistance=100000000
		local nearestPoint
		for m in pointsToMeasure do 
		(
			local thisDistance=distance vert2dPos [pointsPositions[m].x,pointsPositions[m].y]
			if thisDistance<smallestDistance do 
			(
				smallestDistance=thisDistance
				nearestPoint=pointsPositions[m]
			)
		)
		append newVertsPos [thisVertPos.x,thisVertPos.y,nearestPoint.z]
	)

		polyOpSetVert resultplane verts newVertsPos
		if mlptSettings.debug_mode and notfound>0 do format "Point cloud verts slow lookup: %\n" notfound
	/*
		if resultPlane.numfaces>1 then createAndAttachToEditPolyMod originalObj resultPlane updateModifier:updateModifier tagWithAppData:tagWithAppData
		else 
			(
				delete resultPlane
				select originalObj
				returnValue=#emptyResult
			)
		
	*/
	resultPlane.name=originalObj.name+":Terrain"

	
	
	delete $mlpt_temp*
	returnValue
)
fn doTerrain=
(
	updateAllRolloutSettings() --refresh to update subdivs for square constraint

	if mlptSettings.debug_mode do 
	(
		heapBegin=heapfree
		startTime = timeStamp()
		local max_version=(maxVersion())[1] / 1000.0
		
		format "============================================================\n"
		format "Populate:Terrain - Processing started at %\n" localTime
		format "Version: % - 3ds max: %\n" populate_version max_version
	)
	
	mlpt_dialog_populate.prg_progress.value=10
	mlpt_dialog_populate.prg_progress.visible=true

		--escape enable turned off, safe interruption with own progressbar cancel
	local oldEscapeEnable = escapeEnable 
	escapeEnable = false
	setWaitCursor()
	redrawviews()	--prevent crash?
	stopRedrawPanel()
	
	local thisObj=getCurrentObject()
	
		--delete populate:terrain generated relax and turbosmooth mods
	deleteRelaxTurboSmoothMods thisObj
	
		--check if populate:terrain modifier already present for update
	local thisObjFirstModifier=thisObj.modifiers[1]
	local hasAppdata=undefined
	if (thisObjFirstModifier!=undefined) do hasAppdata=getAppData thisObjFirstModifier randomAppDataID
	local modifierToUpdate=
	(
		if hasAppdata!=undefined then --disable previous populate:terrain modifier, to be able to detect base object
		(
			if mlptSettings.debug_mode do format "Updating existing modifier...\n"
			thisObjFirstModifier.enabled=false
			thisObjFirstModifier
		)
		else undefined
	)
	
		--check if base object is spline
	if isShapeObject thisObj then
	(
		if mlptSettings.debug_mode do format "Base object is a spline\n"
		local thisMeshingMethod
		
			--Auto detect best meshing method
		if mlptSettings.automethod then 
		(
			case (autoDetectSplineMeshingMode thisObj) of
			(
				1:
				(
					thisMeshingMethod=#fill
					if mlptSettings.debug_mode do format "Spline Meshing: Auto - Using Fill mode\n"
				)
				2:
				(
					thisMeshingMethod=#terrainCompound
					if mlptSettings.debug_mode do format "Spline Meshing: Auto - Using Contour Lines mode\n"
				)
			)
		)
		else case mlptSettings.meshingmethod of
		(
			1: thisMeshingMethod=#fill
			2: thisMeshingMethod=#terrainCompound
			3: thisMeshingMethod=#pointCloud
		)
		
		if thisMeshingMethod==#terrainCompound or thisMeshingMethod==#pointCloud do
		(
			local thisGridEdgeLength=(if mlptSettings.size_x <= mlptSettings.size_y then mlptSettings.size_x else mlptSettings.size_y)
			local thisNormalizeLength=thisGridEdgeLength
			if mlptSettings.debug_mode do format "Spline normalizing length: %\n" (units.formatValue thisNormalizeLength)
		)
	)
	else --mesh
	(
		if mlptSettings.debug_mode do format "Base object is a mesh\n"	
		
		case mlptSettings.meshingmethod of
		(
			1: thisMeshingMethod=#retopoMesh
			2: thisMeshingMethod=#pointCloud
		)
	)
	
	local optimizeBorderEdges=(mlptSettings.bordermode==1)
	local trimToGrid=(mlptSettings.bordermode==3)
	
	local trimShape=undefined
	if mlptSettings.cookie_cut do
	(
		trimShape=getNodeFromHandle mlptSettings.cookie_cut_nodehandle
	)
	
	try(mlpt_dialog_populate.lbl_status.text="Selected: "+mlpt_currentObject.name+"\nProcessing..."); catch();
	if isValidNode thisObj do 
	(
		if thisMeshingMethod==#pointCloud then mlpt_returnValue=startPointCloudTerrainCreation thisObj subdivs_x:mlptSettings.subdivs_x subdivs_y:mlptSettings.subdivs_y normalizeLength:thisNormalizeLength thisProgressBar:mlpt_dialog_populate.prg_progress tagWithAppData:true trimShape:trimShape
		else mlpt_returnValue=startTerrainCreation thisObj subdivs_x:mlptSettings.subdivs_x subdivs_y:mlptSettings.subdivs_y optimizeBorderEdges:optimizeBorderEdges trimToGrid:trimToGrid shapeMode:thisMeshingMethod normalizeLength:thisNormalizeLength thisProgressBar:mlpt_dialog_populate.prg_progress updateModifier:modifierToUpdate tagWithAppData:true trimShape:trimShape trimInvert:mlptSettings.cookie_invert
	)
	if mlptSettings.relax_on do addRelaxMod thisObj mlptSettings.relax_value mlptSettings.relax_iterations tagWithAppData:true
	if mlptSettings.turbosmooth_on do addTurboSmoothMod thisObj mlptSettings.turbosmooth_iterations mlptSettings.turbosmooth_isolinedisplay tagWithAppData:true

	resumeRedrawPanel()
	setArrowCursor()
		--restore target object end
	escapeEnable = oldEscapeEnable
	mlpt_dialog_populate.prg_progress.visible=false
	
	storeSettingsIntoModifier thisObj
	
	if mlptSettings.debug_mode do 
	(
		redrawTime=(timeStamp() - startTime) / 1000.0
		heapEnd=(heapBegin-heapFree) as float
		format "Total calculation time: % sec\nLeak: %\n" redrawTime ((heapEnd / 1000) as integer)
		
		format "Processing ended at                      %\n" localTime
		format "============================================================\n"
		gc lite:true
	)
	
)
--------------------------------------------
-- TERRAIN CREATION FUNCTIONS END
--------------------------------------------

fn objectSelected updateStatusText:true=
(
		--get appdata settings from modifier. update dialog settings if appdata
	if (mlpt_currentObject.modifiers[1]!=undefined) do local thisObjectSettings=getAppData mlpt_currentObject.modifiers[1] randomAppDataSettings
	if thisObjectSettings!=undefined do
	(
		thisObjectSettings=try(execute thisObjectSettings)
		catch(thisObjectSettings=undefined)
		if thisObjectSettings!=undefined do 
		(
				--only update if appdata is created from matching script version
			if isProperty thisObjectSettings "version" and thisObjectSettings.version==populate_version do 
			(
				mlptSettings=thisObjectSettings
			)
		)
	)
	
		--OBJECT IS SPLINE
	if (getBaseObjectType mlpt_currentObject)==#spline then 
	(
		--mlpt_ro_common.drp_meshingmethod.items=#("Fill with Island Detection", "Contour Lines", "Vertex Point Cloud") --disabled foer beta
		mlpt_ro_common.drp_meshingmethod.items=#("Fill with Island Detection", "Contour Lines")
		mlpt_ro_common.drp_meshingmethod.selection=(if mlptSettings.meshingmethod>0 and mlptSettings.meshingmethod<=mlpt_ro_common.drp_meshingmethod.items.count then mlptSettings.meshingmethod else 1)
		mode_string="Mode: Spline Meshing"
		
		if mlpt_ro_common.chk_automethod.checked then 
		(
			mlptSettings.meshingmethod=mlpt_ro_common.drp_meshingmethod.selection=autoDetectSplineMeshingMode mlpt_currentObject
		)
	)
	else --OBJECT IS MESH 
	(
		--mlpt_ro_common.drp_meshingmethod.items=#("Surface Retopology", "Vertex Point Cloud")
		mlpt_ro_common.drp_meshingmethod.items=#("Surface Retopology")
		mlpt_ro_common.drp_meshingmethod.selection=(if mlptSettings.meshingmethod>0 and mlptSettings.meshingmethod<=mlpt_ro_common.drp_meshingmethod.items.count then mlptSettings.meshingmethod else 1)
		mode_string="Mode: Surface Retopology"
	)
	
	try(mlpt_dialog_populate.lbl_status.text="Selected: "+mlpt_currentObject.name+"\n"+mode_string+"\nReady for processing."); catch();
	try(mlpt_dialog_populate.btn_process.enabled=true); catch();

	
	--linkRelaxMod mlpt_currentObject mlpt_ro_postprocessing.spn_relax_value mlpt_ro_postprocessing.spn_relax_iterations
	--linkTurboSmoothMod mlpt_currentObject  mlpt_ro_postprocessing.spn_turbosmooth_iterations
)

-----------------------------------
-- ROLLOUTS START
-----------------------------------
rollout mlpt_ro_common "Surface"
(
	group "Grid"
	(
		radiobuttons rdo_subdivs_type "Mode" labels:#("Subdivs", "Size", "Percent") default:mlptSettings.subdiv_mode align:#right offset:[-10,-3]
		spinner spn_subdivs_X "X:" align:#left fieldwidth:90 type:#integer range:[2,1e9,mlptSettings.subdivs_x] tooltip:"" offset:[0,-30]
		spinner spn_subdivs_Y "Y:" align:#left fieldwidth:90 type:#integer range:[2,1e9,mlptSettings.subdivs_y] tooltip:""
		checkbox chk_square "Approximate Square" align:#left across:2 checked:mlptSettings.square offset:[0,2] tooltip:"Use square grid subdivisions if possible"
		checkbutton chk_preview "Preview Grid" offset:[-17,-2] align:#left checked:false tooltip:"Show preview grid with current subdivision settings in the active viewport"
		spinner spn_size_X "X:" align:#left fieldwidth:90 type:#worldunits range:[0,1e9,mlptSettings.size_x] tooltip:"" offset:[0,-20] visible:false
		spinner spn_size_Y "Y:" align:#left fieldwidth:90 type:#worldunits range:[0,1e9,mlptSettings.size_y] tooltip:"" offset:[0,-20] visible:false
		spinner spn_percent_X "X:" align:#left fieldwidth:90 type:#float range:[0,100,mlptSettings.percent_x] tooltip:"" offset:[0,-20] visible:false
		spinner spn_percent_Y "Y:" align:#left fieldwidth:90 type:#float range:[0,100,mlptSettings.percent_y] tooltip:"" offset:[0,-20] visible:false
	)
	group "Meshing"
	(
		checkbox chk_automethod "Detect Best Method" across:2 offset:[0,2] align:#left checked:mlptSettings.square tooltip:"Auto detect optimal meshing method"
		dropdownlist drp_meshingmethod "" align:#right width:170 offset:[0,-1] default:mlptSettings.meshingmethod tooltip:"Meshing method"
	)
	groupbox grp1 "Border" pos:[4,156] width:180 height:70
	groupbox grp2 " " pos:[190,156] width:141 height:70
	--radiobuttons rdo_border "Edge Resolution" labels:#("Optimize", "Exact", "Grid") offset:[0,-50] default:mlptSettings.bordermode align:#left tooltip:#("Collapse border edges to grid cell length", "Keep all border vertices of the original geometry", "Coarse trimming to whole quad faces")		
	radiobuttons rdo_border "Edge Resolution" labels:#("Optimize", "Keep Original") offset:[0,-50] default:mlptSettings.bordermode align:#left tooltip:#("Collapse border edges to grid cell length", "Keep all border vertices of the original geometry")		
	checkbox chk_cookie_cut "Trimming" offset:[188,-60]
	pickbutton pck_cookie_cut_spline "Pick Spline" autoDisplay:true align:#right width:123 offset:[-1,0] filter:pickFiltSpline
	checkbox chk_cookie_invert "Invert" align:#right default:mlptSettings.cookie_invert

	fn updateSettings overwrite:false autoUpdate:false =
	(
		local currentObject=getCurrentObject()
		local currentObjectDimensions=getBBox currentObject
		
		if overwrite then
		(
			mlptSettings.subdiv_mode=rdo_subdivs_type.state
			mlptSettings.subdivs_x=spn_subdivs_X.value
			mlptSettings.subdivs_y=spn_subdivs_Y.value
			mlptSettings.size_x=spn_size_X.value
			mlptSettings.size_y=spn_size_Y.value
			mlptSettings.percent_x=spn_percent_X.value
			mlptSettings.percent_y=spn_percent_Y.value
			mlptSettings.bordermode=rdo_border.state
			mlptSettings.meshingmethod=drp_meshingmethod.selection
			mlptSettings.square=chk_square.state
			mlptSettings.automethod=chk_automethod.state
			mlptSettings.cookie_cut=chk_cookie_cut.state
			mlptSettings.cookie_cut_nodehandle=getHandleFromNode pck_cookie_cut_spline.object
			mlptSettings.cookie_invert=chk_cookie_invert.state

			storeSettingsIntoModifier currentObject
		)
		else
		(
			rdo_subdivs_type.state=mlptSettings.subdiv_mode
			spn_subdivs_X.value=mlptSettings.subdivs_x
			spn_subdivs_Y.value=mlptSettings.subdivs_y
			spn_size_X.value=mlptSettings.size_x
			spn_size_Y.value=mlptSettings.size_y
			spn_percent_X.value=mlptSettings.percent_x
			spn_percent_Y.value=mlptSettings.percent_y
			rdo_border.state=mlptSettings.bordermode
			drp_meshingmethod.selection=mlptSettings.meshingmethod
			chk_square.state=mlptSettings.square
			chk_automethod.state=mlptSettings.automethod
			chk_cookie_cut.state=mlptSettings.cookie_cut
			chk_cookie_invert.state=mlptSettings.cookie_invert
			
			--print mlptSettings.cookie_cut_nodehandle
			local cookie_cut_spline=getNodeFromHandle mlptSettings.cookie_cut_nodehandle
			if (isValidNode currentObject and isValidNode cookie_cut_spline and isShapeObject cookie_cut_spline) then 
			(
				pck_cookie_cut_spline.object=cookie_cut_spline
				pck_cookie_cut_spline.text=cookie_cut_spline.name
			)
			else 
			(
				pck_cookie_cut_spline.object=undefined
				pck_cookie_cut_spline.text="Pick Spline"
			)
		)

		case rdo_subdivs_type.state of
		(
			1:
			(
				spn_size_X.visible = spn_size_Y.visible = spn_percent_X.visible = spn_percent_Y.visible = false
				spn_subdivs_X.visible = spn_subdivs_Y.visible = true
				
				if isValidNode currentObject do
				(
					local gridSizeX=currentObjectDimensions.x/mlptSettings.subdivs_x
					local gridSizeY=currentObjectDimensions.y/mlptSettings.subdivs_y
					local percentX=gridSizeX/currentObjectDimensions.x*100.0
					local percentY=gridSizeY/currentObjectDimensions.y*100.0
					spn_size_X.value=mlptSettings.size_x=gridSizeX
					spn_size_Y.value=mlptSettings.size_y=gridSizeY
					spn_percent_X.value=mlptSettings.percent_x=percentX
					spn_percent_Y.value=mlptSettings.percent_y=percentY
				)
			)
			2:
			(
				spn_subdivs_X.visible = spn_subdivs_Y.visible = spn_percent_X.visible = spn_percent_Y.visible = false
				spn_size_X.visible = spn_size_Y.visible = true
				
				if isValidNode currentObject do
				(
					local subdivsX=roundFloat(currentObjectDimensions.x/mlptSettings.size_x) as integer
					local subdivsY=roundFloat(currentObjectDimensions.y/mlptSettings.size_y) as integer
					local percentX=mlptSettings.size_x/currentObjectDimensions.x*100.0
					local percentY=mlptSettings.size_y/currentObjectDimensions.y*100.0
					spn_subdivs_X.value=mlptSettings.subdivs_x=subdivsX
					spn_subdivs_Y.value=mlptSettings.subdivs_y=subdivsY
					spn_percent_X.value=mlptSettings.percent_x=percentX
					spn_percent_Y.value=mlptSettings.percent_y=percentY
				)
			)
			3:
			(
				spn_subdivs_X.visible = spn_subdivs_Y.visible = spn_size_X.visible = spn_size_Y.visible = false
				spn_percent_X.visible = spn_percent_Y.visible = true
				
				if isValidNode currentObject do
				(
					local gridSizeX=mlptSettings.percent_x/100.0*currentObjectDimensions.x
					local gridSizeY=mlptSettings.percent_y/100.0*currentObjectDimensions.y
					local subdivsX=roundFloat(currentObjectDimensions.x/gridSizeX) as integer
					local subdivsY=roundFloat(currentObjectDimensions.y/gridSizeY) as integer
					spn_subdivs_X.value=mlptSettings.subdivs_x=subdivsX
					spn_subdivs_Y.value=mlptSettings.subdivs_y=subdivsY
					spn_size_X.value=mlptSettings.size_x=gridSizeX
					spn_size_Y.value=mlptSettings.size_y=gridSizeY
				)
			)
		)

		--greyed out ui elements
		local controls_enabled=isValidNode currentObject
	
		rdo_subdivs_type.enabled=spn_subdivs_X.enabled=spn_subdivs_Y.enabled=spn_size_X.enabled=spn_size_Y.enabled=spn_percent_X.enabled=spn_percent_Y.enabled=\
		rdo_border.enabled=drp_meshingmethod.enabled=chk_square.enabled=chk_automethod.enabled=chk_cookie_cut.enabled=chk_cookie_invert.enabled=\
		chk_preview.enabled=pck_cookie_cut_spline.enabled=chk_cookie_invert.enabled=controls_enabled
		
		if controls_enabled do
		(
			pck_cookie_cut_spline.enabled=chk_cookie_invert.enabled=chk_cookie_cut.checked
			drp_meshingmethod.enabled=not chk_automethod.checked and drp_meshingmethod.items.count>0

		)
		
		if chk_square.checked then 
		(
			if controls_enabled do spn_subdivs_Y.enabled = spn_size_Y.enabled = spn_percent_Y.enabled = false
			
			if isValidNode currentObject then
			(
				spn_subdivs_Y.indeterminate = spn_size_Y.indeterminate = spn_percent_Y.indeterminate = false --empty spinner false
				
				local gridCountY=currentObjectDimensions.y/mlptSettings.size_x
				gridCountY=roundFloat gridCountY as integer
				mlptSettings.subdivs_y=spn_subdivs_Y.value=gridCountY
			)
			else
			(
				spn_subdivs_Y.indeterminate = spn_size_Y.indeterminate = spn_percent_Y.indeterminate = true --empty spinner
			)
		)
		else
		(
			if controls_enabled do spn_subdivs_Y.enabled = spn_size_Y.enabled = spn_percent_Y.enabled = true
			spn_subdivs_Y.value=spn_subdivs_Y.value --hack to make spinner content visible again after .indeterminate = true
			spn_size_Y.value=spn_size_Y.value --hack
			spn_percent_Y.value=spn_percent_Y.value --hack
		)
		
		if autoUpdate do mlpt_dialog_populate.doAutoUpdate()
		
		mlpt_subdivsX=mlptSettings.subdivs_x
		mlpt_subdivsY=mlptSettings.subdivs_y
				
		if mlpt_ro_common.chk_preview.state do redrawviews()
	)
	
	on rdo_subdivs_type changed a do updateSettings overwrite:true
	on spn_subdivs_X changed a do updateSettings overwrite:true
	on spn_subdivs_X entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_subdivs_Y changed a do updateSettings overwrite:true
	on spn_subdivs_Y entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_size_X changed a do updateSettings overwrite:true
	on spn_size_X entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_size_Y changed a do updateSettings overwrite:true
	on spn_size_Y entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_percent_X changed a do updateSettings overwrite:true
	on spn_percent_X entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_percent_Y changed a do updateSettings overwrite:true
	on spn_percent_Y entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on rdo_border changed a do updateSettings overwrite:true autoUpdate:true
	on drp_meshingmethod selected a do updateSettings overwrite:true autoUpdate:true
	on chk_square changed a do updateSettings overwrite:true autoUpdate:true
	on chk_automethod changed a do 
	(
		updateSettings overwrite:true autoUpdate:true
		if a==true do objectSelected updateStatusText:false
	)
	on chk_preview changed a do mlpt_dialog_populate.dialog_refresh()
	on chk_cookie_cut changed a do updateSettings overwrite:true autoUpdate:true
	on pck_cookie_cut_spline picked a do updateSettings overwrite:true autoUpdate:false
	on chk_cookie_invert changed a do updateSettings overwrite:true autoUpdate:true
		
	on mlpt_ro_common open do
	(
		spn_size_X.pos=spn_percent_X.pos=spn_subdivs_X.pos --position of invisible spinners
		spn_size_Y.pos=spn_percent_Y.pos=spn_subdivs_Y.pos
	)
)
rollout mlpt_ro_postprocessing "Post Processing"
(
	spinner spn_relax_value "Value:" offset:[-10,20] across:2 align:#right fieldwidth:70 type:#float range:[0,1,mlptSettings.relax_value] tooltip:""
	spinner spn_turbosmooth_iterations "Iterations:" offset:[0,20] align:#right fieldwidth:70 type:#integer range:[1,10,mlptSettings.turbosmooth_iterations] tooltip:""
	spinner spn_relax_iterations "Iterations:" offset:[-10,0] across:2 align:#right fieldwidth:70 type:#integer range:[0,1e9,mlptSettings.relax_iterations] tooltip:""
	checkbox chk_turbosmooth_isolinedisplay "Isoline Display" align:#right checked:mlptSettings.turbosmooth_isolinedisplay
	groupbox grp1 " " pos:[4,7] width:160 height:65
	groupbox grp2 " " pos:[170,7] width:161 height:65
	checkbox chk_relax_on "Relax" pos:[15,7] checked:mlptSettings.relax_on
	checkbox chk_turbosmooth_on "TurboSmooth" pos:[180,7] checked:mlptSettings.turbosmooth_on 
	
	fn updateSettings overwrite:false autoUpdate:false =
	(
		if overwrite then
		(
			mlptSettings.relax_value=spn_relax_value.value
			mlptSettings.turbosmooth_iterations=spn_turbosmooth_iterations.value
			mlptSettings.relax_iterations=spn_relax_iterations.value
			mlptSettings.turbosmooth_isolinedisplay=chk_turbosmooth_isolinedisplay.state
			mlptSettings.relax_on=chk_relax_on.state
			mlptSettings.turbosmooth_on=chk_turbosmooth_on.state
			
			local currentObject=getCurrentObject()
			storeSettingsIntoModifier currentObject
		)
		else
		(
			spn_relax_value.value=mlptSettings.relax_value
			spn_turbosmooth_iterations.value=mlptSettings.turbosmooth_iterations
			spn_relax_iterations.value=mlptSettings.relax_iterations
			chk_turbosmooth_isolinedisplay.state=mlptSettings.turbosmooth_isolinedisplay
			chk_relax_on.state=mlptSettings.relax_on
			chk_turbosmooth_on.state=mlptSettings.turbosmooth_on
		)
		
			--greyed out ui elements
		local currentObject=getCurrentObject()
		local controls_enabled=isValidNode currentObject
		spn_relax_value.enabled=spn_turbosmooth_iterations.enabled=spn_relax_iterations.enabled=chk_turbosmooth_isolinedisplay.enabled=chk_relax_on.enabled=chk_turbosmooth_on.enabled=controls_enabled
		if controls_enabled then
		(
			spn_relax_value.enabled=chk_relax_on.checked
			spn_relax_iterations.enabled=chk_relax_on.checked
			spn_turbosmooth_iterations.enabled=chk_turbosmooth_on.checked
			chk_turbosmooth_isolinedisplay.enabled=chk_turbosmooth_on.checked
		)

		
		if autoUpdate do mlpt_dialog_populate.doAutoUpdate()
	)
	
	on spn_relax_value entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_turbosmooth_iterations entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on spn_relax_iterations entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
	on chk_turbosmooth_isolinedisplay changed a do updateSettings overwrite:true autoUpdate:true
	on chk_relax_on changed a do updateSettings overwrite:true autoUpdate:true
	on chk_turbosmooth_on changed a do updateSettings overwrite:true autoUpdate:true
)
rollout mlpt_ro_advanced "Terrain plus"
(
	group "Adaptive Tesselation"
	(
		checkbox chk_enable_adaptive "Enable" across:2 checked:mlptSettings.adaptive_refinement
		spinner spn_vertspercell "Verts per Cell:" align:#right fieldwidth:70 type:#integer range:[1,1e9,mlptSettings.adaptive_refinement_vertspercell] tooltip:""
		spinner spn_iterations "Max Iterations:" align:#right fieldwidth:70 type:#integer range:[1,16,mlptSettings.adaptive_refinement_maxsubdivs] tooltip:"" 
	)


	fn updateSettings overwrite:false autoUpdate:false =
	(
		if overwrite then
		(
			mlptSettings.adaptive_refinement=chk_enable_adaptive.state
			mlptSettings.adaptive_refinement_vertspercell=spn_vertspercell.value
			mlptSettings.adaptive_refinement_maxsubdivs=spn_iterations.value
		)
		else
		(
			chk_enable_adaptive.state=mlptSettings.adaptive_refinement
			spn_vertspercell.value=mlptSettings.adaptive_refinement_vertspercell
			spn_iterations.value=mlptSettings.adaptive_refinement_maxsubdivs
		)
		if autoUpdate do mlpt_dialog_populate.doAutoUpdate()
	)
	
	on chk_enable_adaptive changed a do updateSettings overwrite:true autoUpdate:true
	on spn_vertspercell changed a do updateSettings overwrite:true autoUpdate:true
	on spn_iterations entered inSpin_arg inCancel_arg do updateSettings overwrite:true autoUpdate:true
		
	on mlpt_ro_advanced open do
	(
		updateSettings()
	)
)
rollout mlpt_ro_about "About"
(
	--dotNetControl wb "System.Windows.Forms.WebBrowser" pos:[5,5] width:325 height:355
	label lbl_version align:#left	
	hyperlink hyp_link"Check Github for the source code " address:"https://github.com/mxdsa/populateTerrain" color:blue hovercolor:blue 	
	hyperlink hyp_link2"Populate3d offical website" address:"http://populate3d.com/products/terrain?ref=terrain" color:blue hovercolor:blue 
	
	label lbl_compinfo align:#left height:55
	on mlpt_ro_about open do
	(

		lbl_version.text=populate_title
		lbl_compinfo.text  ="This software is free and unlimited for personal and \ncommercial use.\n\n"
		lbl_compinfo.text+="\xa9 2011-2012 Marc Lorenz. All rights reserved."
		
		--wb.url = dotNetObject "System.Uri" "http://www.marclorenz.com/populate/"
		--wb.ScrollBarsEnabled  = false
		--wb.ScriptErrorsSuppressed = true
		--wb.IsWebBrowserContextMenuEnabled = false
	)
)
rollout mlpt_ro_debug "Options"
(
	checkbox chk_debug "Print stats into the MAXScript listener" offset:[0,8] checked:mlptSettings.debug_mode
	
	fn updateSettings overwrite:false autoUpdate:false =
	(
		local currentObject=getCurrentObject()
		local currentObjectDimensions=getBBox currentObject
		
		if overwrite then
		(
			mlptSettings.debug_mode=chk_debug.state
		)
		else
		(
			chk_debug.state=mlptSettings.debug_mode
		)
	)
	
	on chk_debug changed a do updateSettings overwrite:true autoUpdate:true

	on mlpt_ro_debug open do
	(
		updateSettings overwrite:true
	)


)
-----------------------------------
-- ROLLOUTS END
-----------------------------------

-----------------------------------------------
--CONTAINER DIALOG START
-----------------------------------------------
local tab_rollouts = 
#(
	--#(" Common ",#(mlpt_ro_common, mlpt_ro_postprocessing, mlpt_ro_advanced)),
	#(" Common ",#(mlpt_ro_common, mlpt_ro_postprocessing)),
	--#(" About ",#(mlpt_ro_about, mlpt_ro_debug))
	#(" About ",#(mlpt_ro_about))

	--#("+",#(mlpt_ro_about))
)

rollout mlpt_dialog_populate populate_title
(
	dotNetControl img_logo "System.Windows.Forms.PictureBox" pos:[5,5] height:68 width:338
	dotNetControl tabs "System.Windows.Forms.TabControl" height:28 width:338 pos:[5,80]
	subRollout subRollout1 width:348 height:(mlptSettings.dialog_height-90) align:#center pos:[5,110] 
	subRollout subRollout2 width:348 height:(mlptSettings.dialog_height-90) align:#center pos:[5,110] visible:off
	subRollout subRollout3 width:348 height:(mlptSettings.dialog_height-90) align:#center pos:[5,110] visible:off
	checkbox chk_interactive "Interactive" pos:[190,mlptSettings.dialog_height-34] tooltip:"Update terrain settings in realtime for already processed objects"
	button btn_process "Process" pos:[269,mlptSettings.dialog_height-47] width:74 height:42 tooltip:"Generate terrain"
	label lbl_status "" pos:[5,mlptSettings.dialog_height-47] width:175 height:42 style_sunkenedge:true
	progressBar prg_progress "" height:2 color:mlpt_green pos:[0,0] width:350 visible:false
	
	local sub_rollouts = #(subRollout1, subRollout2, subRollout3)

	-----------------------------------------------
	-- DOTNET BASE64 IMAGE DECODER START
	-----------------------------------------------
		--put this in main dialog rollout to be able to access it from outside filein's (framingSystem) using mlpt_dialog_populate.ConvertBase64StringToImage
	local ConvertClass = dotnetclass "system.convert"
	local ImageClass = dotnetclass "system.drawing.image"
	fn ConvertBase64StringToImage string =
	(
		bytearr = convertclass.FromBase64String string
		memstream = dotnetobject "System.IO.MemoryStream" bytearr
		DecodedImg = ImageClass.fromstream memstream
		memstream.close()
		DecodedImg
	)
	-----------------------------------------------
	-- DOTNET BASE64 IMAGE DECODER END
	-----------------------------------------------

	fn dialog_refresh updateStatus:true =
	(
		local new_height=mlpt_dialog_populate.height
		mlptSettings.dialog_height=new_height
		mlpt_dialogPos=GetDialogPos mlpt_dialog_populate

		btn_process.pos.y =  new_height-47
		lbl_status.pos.y = new_height-47
		chk_interactive.pos.y = new_height-34
		prg_progress.pos.y =new_height-55

		for thisRollout in sub_rollouts do
		(
			thisRollout.position.y=110
			thisRollout.height=new_height-162
		)
		
		btn_process.pos.x=269
		tabs.pos.x=5

		if updateStatus do
		(
			if isValidNode mlpt_currentObject then
			(
				objectSelected() --slow?
				
				if chk_interactive.checked then
				(
					--btn_process.enabled=false
				)
				else
				(
					--btn_process.enabled=true
				)
			)
			else
			(
				mlpt_ro_common.drp_meshingmethod.items=#()
				btn_process.enabled=false
			)
			
			if mlpt_returnValue!=undefined and updateStatus do
			(
				case mlpt_returnValue of
				(
					#ok: try(lbl_status.text="Status: Terrain created."); catch();
					#emptyResult:try(lbl_status.text="ERROR: Could not create terrain."); catch();
				)
				mlpt_returnValue=undefined
			)
			
					--preview grid
			if mlpt_ro_common.chk_preview.checked then register_boundinggrid()
			else unregister_boundinggrid()

			updateAllRolloutSettings()
		)
	)
	fn createTabInterface thisTabControl:tabs=
	(
		thisTabControl.TabPages.Clear()
		thisTabControl.Multiline=false
		thisTabControl.Padding.Y=5
		
		for k=1 to tab_rollouts.count do 
			(
				tabs.TabPages.add tab_rollouts[k][1]
				for r in tab_rollouts[k][2] do addSubRollout sub_rollouts[k] r
			)
	)
	
	on tabs selected sel do for k=0 to tabs.TabPages.count-1 do sub_rollouts[k+1].visible = (k == sel.TabPageIndex)
	
	on chk_interactive changed a do 
	(
		dialog_refresh()
		if a==true do mlpt_dialog_populate.doAutoUpdate()
	)
	on btn_process pressed do if selection[1]!=undefined do undo off  doTerrain()
	
	fn initImgLogo=
	(
		local cursors = dotNetClass "System.Windows.Forms.Cursors"
		img_logo.cursor= cursors.Hand
	)
	on img_logo MouseUp arg do
 	(
 		if arg.button == arg.button.left AND
 			img_logo.bounds.Contains arg.location do
 				ShellLaunch "http://populate3d.com/?ref=terrain" ""
 	)

	on mlpt_dialog_populate open do
	(
		initImgLogo()
		img_logo.backgroundImageLayout = (dotNetClass "System.Windows.Forms.ImageLayout").zoom
		img_logo.backgroundImage = mlpt_dialog_populate.ConvertBase64StringToImage "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"
		
		createTabInterface()
	
		mlpt_currentObject=getCurrentObject()
		dialog_refresh()
		
		resumeRedraw() --fix stuck mod panel if script previously crashed
		forcecompleteredraw()
	)
	on mlpt_dialog_populate resized thisNewsize do dialog_refresh updateStatus:false
	on mlpt_dialog_populate close do
	(
		mlpt_dialogPos=GetDialogPos mlpt_dialog_populate --store dialog position for next run in current session
		
		unregister_boundinggrid() --remove preview grid callback

		img_logo.backgroundImage.dispose()
		img_logo.dispose()
		
		mlpt_objChangedRemove no_gc:true
		
		gc lite:true
			--dotNet garbage collection
		local dgc = dotnetclass "system.gc"
		dgc.collect()
		mlpt_dialog_populate=undefined
	)

	fn doAutoUpdate=
	(
		if chk_interactive.checked and selection[1]!=undefined do 
		(
			btn_process.enabled=false
			doTerrain()
			
		)
	)
)
-----------------------------------------------
--CONTAINER DIALOG END
-----------------------------------------------

	--check if max version is 2010 or higher
if (maxversion())[1]<12000 then
	(
		messageBox "Sorry, only 3dsmax 2010 or higher is supported." title:"Error"
	)
	--run dialog
else createDialog mlpt_dialog_populate mlptSettings.dialog_width mlptSettings.dialog_height pos:mlpt_dialogPos lockWidth:true style:#(#style_titlebar, #style_border, #style_sysmenu, #style_resizing,#style_minimizebox)
	
)
